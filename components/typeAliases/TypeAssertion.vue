<template>
    <div class="flex items-center justify-center">
        <div class="w-3/4 bg-slate-800 mt-10 rounded-lg p-5">
            <h2 class="text-left text-lg"> Type assertion </h2>
            <hr class="border-slate-700 my-2.5" />
            <p class="mt-3">
                Type assertion представляет модель преобразования значения переменной к определенному типу. Обычно в некоторых ситуациях одна переменная может представлять какой-то широкий тип, например, any или union, которые по факту допускают значения различных типов. Однако при этом нам надо использовать переменную как значение строго определенного типа. И в этом случае мы можем привести к этому типу.
            </p>
            <p class="mt-3">
                В качестве примера возьмем простейшую задачу - на веб-странице есть html-элемент с id = header, и мы хотим получить этот элемент, например, чтобы изменить его текст. Для получения элемента по id мы могли бы использовать встроенную js-функцию document.getElementById():
            </p>
            <p class="mt-3">
                <code class="text-teal-500"> const header = document.getElementById("header"); </code>
            </p>
            <p class="mt-3">
                Но в TypeScript эта функция возвращает объединение HTMLElement|null. То есть возвращаемое значение может представлять null, если соответствующий html-элемент отсутствует на веб-странице. Вследствие этого обращение к свойству header.innerText - к свойству объекта, который может быть null, содержит потенциальную ошибку. Поэтому компилятор при компиляции сгенерирует ошибку.
            </p>
            <p class="mt-3">
                Однако ситуация может быть такова, что мы точно знаем, что у нас на странице есть такой элемент. Есть разные способы для решения этой проблемы, чтобы указать компилятору, что все нормально. И одним из ним является приведение типов с помощью type assertion.
            </p>
            <p class="mt-3">
                <code class="text-teal-500">const header = HTMLElement document.getElementById("header"); </code> 
                <p>или</p>
                <code class="text-teal-500">const header = document.getElementById("header") as HTMLElement; </code>
            </p>
            <p class="mt-3">
                Однако такие преобразования будут иметь силу, если мы точно знаем, что значение может быть преобразовано к целевому типу. Например, на странице есть элемент с id=header, поэтому мы можем преобразовать значение к типу HTMLElement. Однако если такого элемента нет, то во время выполнения мы опять же получим ошибку.
            </p>
        </div>
    </div>
</template>

<script setup>

</script>

<style lang="scss" scoped>

</style>